# CLI Builder Agent Skill

## Purpose
Generate menu-driven CLI interface from feature specification. Creates interactive menu system organized by tier, with input validation, error handling, and colored output.

## Parameters

### Required
- `feature` (string): Feature name to build CLI for (e.g., "todo-core")

### Optional
- `output_file` (string): Where to write CLI (default: `src/todo/cli.py`)
- `include_colors` (boolean): Use colorama for colored output (default: true)
- `tier` (string): Build only specific tier menu (default: "all")

## Usage Examples

```bash
# Generate full CLI for todo-core
Skill: cli-builder --feature todo-core

# Generate only primary tier menu
Skill: cli-builder --feature todo-core --tier primary

# Generate without colors
Skill: cli-builder --feature todo-core --include_colors false
```

## Execution Steps

1. **Load Requirements**
   - Read `.specify/memory/constitution.md` for:
     - Three-tier feature architecture
     - UX requirements (menu structure, error handling, validation)
   - Read `specs/<feature>/spec.md` for:
     - Feature list per tier
     - User stories and acceptance criteria
   - Parse tier-specific features:
     - PRIMARY: add, view, update, delete, mark_complete
     - INTERMEDIATE: search, filter, sort
     - ADVANCED: recurring, reminders

2. **Generate Imports and Setup**
   ```python
   """
   Command-line interface for the Python CLI Todo Application.

   Provides menu-driven interface organized by tier (Primary, Intermediate, Advanced)
   with input validation, error handling, and visual feedback.

   Generated by: cli-builder agent skill
   Feature: <feature>
   Generated: <ISO timestamp>
   """

   import sys
   from typing import Optional, List
   from src.todo.models import Task, Priority, TaskType, RecurrencePattern
   from src.todo.storage import TaskStorage
   from src.todo.commands import (
       add_task, view_tasks, update_task, delete_task, mark_complete,
       search_tasks, filter_tasks, sort_tasks, create_recurring_task
   )

   [If include_colors:]
   try:
       from colorama import init, Fore, Style
       init(autoreset=True)
       COLORS_ENABLED = True
   except ImportError:
       COLORS_ENABLED = False
       Fore = Style = type('', (), {'RED': '', 'GREEN': '', 'YELLOW': '', 'CYAN': '', 'RESET_ALL': ''})()
   ```

3. **Generate Helper Functions**
   ```python
   def print_header(text: str) -> None:
       """Print formatted header."""
       if COLORS_ENABLED:
           print(f"\n{Fore.CYAN}{'=' * 60}")
           print(f"{Fore.CYAN}{text.center(60)}")
           print(f"{Fore.CYAN}{'=' * 60}{Style.RESET_ALL}\n")
       else:
           print(f"\n{'=' * 60}")
           print(text.center(60))
           print(f"{'=' * 60}\n")

   def print_error(message: str) -> None:
       """Print error message in red."""
       if COLORS_ENABLED:
           print(f"{Fore.RED}❌ Error: {message}{Style.RESET_ALL}")
       else:
           print(f"Error: {message}")

   def print_success(message: str) -> None:
       """Print success message in green."""
       if COLORS_ENABLED:
           print(f"{Fore.GREEN}✅ {message}{Style.RESET_ALL}")
       else:
           print(f"✅ {message}")

   def print_warning(message: str) -> None:
       """Print warning message in yellow."""
       if COLORS_ENABLED:
           print(f"{Fore.YELLOW}⚠️  {message}{Style.RESET_ALL}")
       else:
           print(f"⚠️  {message}")

   def get_input(prompt: str, required: bool = True) -> str:
       """Get user input with validation."""
       while True:
           value = input(prompt).strip()
           if value or not required:
               return value
           print_error("This field is required. Please enter a value.")

   def confirm_action(message: str) -> bool:
       """Ask for y/n confirmation."""
       while True:
           response = input(f"{message} (y/n): ").strip().lower()
           if response in ('y', 'yes'):
               return True
           elif response in ('n', 'no'):
               return False
           print_error("Please enter 'y' or 'n'.")
   ```

4. **Generate Tier-Specific Menu Functions**
   ```python
   def show_primary_menu() -> None:
       """Display primary tier menu options."""
       print_header("PRIMARY TIER - Core Operations")
       print("1. Add Task")
       print("2. View All Tasks")
       print("3. Update Task")
       print("4. Delete Task")
       print("5. Mark Task Complete/Incomplete")
       print("0. Back to Main Menu")

   def handle_primary_choice(choice: str, storage: TaskStorage) -> bool:
       """
       Handle primary tier menu choice.
       Returns False if user wants to go back.
       """
       if choice == '1':
           handle_add_task(storage)
       elif choice == '2':
           handle_view_tasks(storage)
       elif choice == '3':
           handle_update_task(storage)
       elif choice == '4':
           handle_delete_task(storage)
       elif choice == '5':
           handle_mark_complete(storage)
       elif choice == '0':
           return False
       else:
           print_error("Invalid option. Please choose 0-5.")
       return True

   [Similar for intermediate_menu and advanced_menu]
   ```

5. **Generate Feature Handlers**
   ```python
   def handle_add_task(storage: TaskStorage) -> None:
       """Handle adding a new task."""
       try:
           print_header("Add New Task")
           title = get_input("Title: ", required=True)
           description = get_input("Description (optional): ", required=False)

           # Priority
           print("\nPriority levels:")
           print("  1. HIGH")
           print("  2. MEDIUM (default)")
           print("  3. LOW")
           priority_choice = get_input("Choose priority (1-3, default 2): ", required=False) or "2"
           priority_map = {"1": Priority.HIGH, "2": Priority.MEDIUM, "3": Priority.LOW}
           priority = priority_map.get(priority_choice, Priority.MEDIUM)

           # Tags
           tags_input = get_input("Tags (comma-separated, e.g., Work,Home): ", required=False)
           tags = set(tag.strip() for tag in tags_input.split(',') if tag.strip())

           # Due date (optional)
           due_date_str = get_input("Due date (YYYY-MM-DD, optional): ", required=False)
           due_date = None
           if due_date_str:
               # TODO: Parse date and handle invalid format
               pass

           task = add_task(storage, title, description, priority, tags, due_date)
           print_success(f"Task created successfully! ID: {task.id}")

       except ValueError as e:
           print_error(str(e))
       except Exception as e:
           print_error(f"An unexpected error occurred: {e}")

   [Similar handlers for view, update, delete, mark_complete, search, filter, sort, etc.]
   ```

6. **Generate Main Menu and Entry Point**
   ```python
   def show_main_menu() -> None:
       """Display main menu with tier organization."""
       print_header("Python CLI Todo Application")
       print(f"{Fore.CYAN if COLORS_ENABLED else ''}TIER SELECTION{Style.RESET_ALL if COLORS_ENABLED else ''}")
       print("1. Primary Tier (Core CRUD Operations)")
       print("2. Intermediate Tier (Organization & Usability)")
       print("3. Advanced Tier (Intelligent Features)")
       print("q. Quit")

   def main() -> None:
       """Main CLI loop."""
       storage = TaskStorage()
       print_header("Welcome to Python CLI Todo Application!")

       while True:
           show_main_menu()
           choice = input("\nChoose a tier (1-3) or 'q' to quit: ").strip().lower()

           if choice == 'q' or choice == 'quit':
               if confirm_action("Are you sure you want to quit?"):
                   print_success("Goodbye!")
                   sys.exit(0)
           elif choice == '1':
               while True:
                   show_primary_menu()
                   primary_choice = input("\nChoose an option: ").strip()
                   if not handle_primary_choice(primary_choice, storage):
                       break
           elif choice == '2':
               while True:
                   show_intermediate_menu()
                   intermediate_choice = input("\nChoose an option: ").strip()
                   if not handle_intermediate_choice(intermediate_choice, storage):
                       break
           elif choice == '3':
               while True:
                   show_advanced_menu()
                   advanced_choice = input("\nChoose an option: ").strip()
                   if not handle_advanced_choice(advanced_choice, storage):
                       break
           else:
               print_error("Invalid option. Please choose 1-3 or 'q'.")

   if __name__ == "__main__":
       main()
   ```

7. **Validate Generated Code**
   - Run mypy: `mypy <output_file> --strict`
   - Run flake8: `flake8 <output_file>`
   - Run black: `black <output_file>`
   - Fix any errors

8. **Generate Report**
   ```
   ==================== CLI BUILDER REPORT ====================
   Feature: <feature>
   Output file: <output_file>
   Timestamp: <ISO datetime>

   [GENERATED COMPONENTS]
   ✅ Helper functions: print_header, print_error, print_success, get_input, confirm_action
   ✅ Menu functions: show_main_menu, show_primary_menu, show_intermediate_menu, show_advanced_menu
   ✅ Choice handlers: handle_primary_choice, handle_intermediate_choice, handle_advanced_choice
   ✅ Feature handlers: <count> (<handler_names>)
   ✅ Main entry point: main()

   [FEATURES BY TIER]
   PRIMARY (5):
     - Add Task
     - View All Tasks
     - Update Task
     - Delete Task
     - Mark Complete/Incomplete

   INTERMEDIATE (3):
     - Search Tasks
     - Filter Tasks
     - Sort Tasks

   ADVANCED (2):
     - Recurring Tasks
     - Due Date Reminders

   [CODE QUALITY]
   ✅ Mypy validation: PASSED
   ✅ Flake8 linting: PASSED
   ✅ Black formatting: Applied
   ✅ Colors enabled: <true/false>
   ✅ Error handling: All functions wrapped in try-except
   ✅ Input validation: All required fields validated

   [NEXT STEPS]
   1. Review generated CLI: <output_file>
   2. Implement command functions in commands.py
   3. Test interactively: python -m src.todo.cli
   4. Add missing date parsing and validation logic
   ===========================================================
   ```

9. **Exit Codes**
   - 0: CLI generated successfully
   - 1: Validation failed
   - 2: File write error

## Acceptance Criteria

- ✅ Generates menu-driven interface organized by tier
- ✅ Includes all features from constitution and spec
- ✅ Implements input validation for all required fields
- ✅ Includes error handling (try-except blocks)
- ✅ Optionally uses colorama for colored output
- ✅ Includes confirmation prompts for destructive actions
- ✅ Supports graceful exit (quit command)
- ✅ Passes all code quality checks (mypy, flake8, black)
- ✅ Provides clear, user-friendly prompts and error messages

## Dependencies

- colorama (optional, for colored output)
- mypy, flake8, black (for validation)

## Error Handling

- **Feature not found**: "Error: Feature '<feature>' not found in specs/"
- **Invalid tier**: "Error: tier must be 'primary', 'intermediate', 'advanced', or 'all'"
- **Output file exists**: "Warning: <output_file> exists. Overwrite? (y/n)"
- **Validation failed**: "Error: Generated code has errors. Review and fix."

## Notes

- Generated CLI is a starting point; customize prompts and validation as needed
- Implement command functions (add_task, view_tasks, etc.) in commands.py
- Test interactively before committing
- Date parsing logic marked as TODO; use dateutil or stdlib datetime.strptime
- Color support gracefully degrades if colorama not installed
